/**
 * SISTEMA PROTEGIDO DE AN√ÅLISE IA - VERS√ÉO 2.0
 * 
 * Este hook implementa um sistema robusto de an√°lise que:
 * 1. Garante que assistentes sempre analisem dados reais
 * 2. Implementa cache inteligente para evitar duplica√ß√µes
 * 3. Protege contra altera√ß√µes futuras no sistema
 * 4. Controla custos automaticamente
 */

import { useState, useCallback } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { supabase } from '@/integrations/supabase/client';
import { useCacheManager } from './useCacheManager';

interface ProtectedAnalysisConfig {
  analysisType: string;
  assistants: Array<{
    id: string;
    name: string;
    prompt: string;
    model: string;
    area: string;
  }>;
  openaiConfig: {
    apiKey: string;
    model: string;
    temperature: number;
    maxTokens: number;
  };
  useCache?: boolean;
  onlyRealData?: boolean;
}

interface AnalysisResult {
  success: boolean;
  fromCache: boolean;
  insights: any[];
  summary: string;
  stats: {
    conversationsAnalyzed: number;
    chatMessagesAnalyzed: number;
    insightsGenerated: number;
    costEstimate: number;
  };
  processingTime: number;
  dataHash: string;
  message: string;
}

export function useProtectedAnalysisSystem() {
  const { user } = useAuth();
  const { 
    checkAnalysisCache, 
    saveAnalysisSummary, 
    generateDataHash 
  } = useCacheManager();
  
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [protectionLevel, setProtectionLevel] = useState<'HIGH' | 'MEDIUM' | 'LOW'>('HIGH');

  /**
   * FUN√á√ÉO PRINCIPAL DE AN√ÅLISE PROTEGIDA
   * Agora busca conversas marcadas para an√°lise no banco
   */
  const executeProtectedAnalysis = useCallback(async (
    config: ProtectedAnalysisConfig
  ): Promise<AnalysisResult | null> => {
    
    if (!user?.id) {
      console.error('üîí SISTEMA PROTEGIDO: Usu√°rio n√£o autenticado');
      return null;
    }

    if (!config.openaiConfig.apiKey || !config.openaiConfig.apiKey.startsWith('sk-')) {
      console.error('üîí SISTEMA PROTEGIDO: Chave OpenAI inv√°lida');
      return null;
    }

    setIsAnalyzing(true);
    console.log('üîí SISTEMA PROTEGIDO: Iniciando an√°lise segura...');

    try {
      // PASSO 1: Buscar conversas marcadas para an√°lise do banco
      console.log('üîç SISTEMA PROTEGIDO: Buscando conversas marcadas para an√°lise...');
      
      const { data: markedConversations, error: markedError } = await supabase
        .from('whatsapp_conversations_analysis')
        .select('*')
        .eq('user_id', user.id)
        .eq('marked_for_analysis', true)
        .eq('analysis_status', 'pending');

      if (markedError) {
        console.error('üîí SISTEMA PROTEGIDO: Erro ao buscar conversas marcadas:', markedError);
      }

      // PASSO 2: Buscar dados reais do banco (incluindo conversas marcadas)
      const realData = await fetchRealUserData(user.id, markedConversations || []);
      
      if (!realData || (realData.conversations.length === 0 && realData.chatHistory.length === 0)) {
        console.warn('üîí SISTEMA PROTEGIDO: Nenhum dado real encontrado');
        return {
          success: false,
          fromCache: false,
          insights: [],
          summary: 'Nenhum dado real encontrado para an√°lise',
          stats: { conversationsAnalyzed: 0, chatMessagesAnalyzed: 0, insightsGenerated: 0, costEstimate: 0 },
          processingTime: 0,
          dataHash: '',
          message: 'Nenhum dado real encontrado'
        };
      }

      // Verificar se h√° conversas marcadas especificamente
      const hasMarkedConversations = markedConversations && markedConversations.length > 0;
      if (hasMarkedConversations) {
        console.log(`üéØ SISTEMA PROTEGIDO: ${markedConversations.length} conversas marcadas para an√°lise priorit√°ria`);
      }

      // PASSO 3: Verificar cache se habilitado
      if (config.useCache !== false) {
        console.log('üîí SISTEMA PROTEGIDO: Verificando cache...');
        const cacheResult = await checkAnalysisCache(
          realData.conversations,
          realData.chatHistory,
          config.analysisType
        );

        if (cacheResult?.cached && !hasMarkedConversations) {
          console.log('üîí SISTEMA PROTEGIDO: Usando dados do cache');
          return {
            success: true,
            fromCache: true,
            insights: [],
            summary: cacheResult.summary.summary_content,
            stats: {
              conversationsAnalyzed: cacheResult.summary.conversations_analyzed,
              chatMessagesAnalyzed: cacheResult.summary.chat_messages_analyzed,
              insightsGenerated: cacheResult.summary.insights_generated,
              costEstimate: cacheResult.summary.cost_estimate
            },
            processingTime: 0,
            dataHash: cacheResult.summary.data_hash,
            message: cacheResult.message
          };
        }
      }

      // PASSO 4: Executar an√°lise com assistentes reais
      console.log('üîí SISTEMA PROTEGIDO: Executando nova an√°lise...');
      const startTime = Date.now();
      
      const analysisData = {
        userId: user.id,
        openaiConfig: config.openaiConfig,
        assistants: config.assistants,
        analysisType: config.analysisType,
        conversationsData: realData.conversations,
        chatHistoryData: realData.chatHistory,
        markedConversations: markedConversations || [],
        useCache: config.useCache !== false,
        onlyRealData: config.onlyRealData !== false,
        timestamp: new Date().toISOString()
      };

      // Atualizar status das conversas marcadas para "processing"
      if (hasMarkedConversations) {
        for (const conversation of markedConversations) {
          await supabase
            .from('whatsapp_conversations_analysis')
            .update({ analysis_status: 'processing' })
            .eq('id', conversation.id);
        }
      }

      // Chamar fun√ß√£o Edge protegida
      const response = await fetch('/api/analyze-conversation', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(analysisData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Erro na an√°lise protegida');
      }

      const result = await response.json();
      const processingTime = Date.now() - startTime;

      // PASSO 5: Atualizar status das conversas analisadas
      if (hasMarkedConversations && result.success) {
        for (const conversation of markedConversations) {
          await supabase
            .from('whatsapp_conversations_analysis')
            .update({ 
              analysis_status: 'completed',
              last_analyzed_at: new Date().toISOString(),
              analysis_results: result.insights || []
            })
            .eq('id', conversation.id);
        }
        console.log('‚úÖ SISTEMA PROTEGIDO: Status das conversas marcadas atualizado');
      }

      console.log('‚úÖ SISTEMA PROTEGIDO: An√°lise conclu√≠da com sucesso');
      
      return {
        success: true,
        fromCache: false,
        insights: result.insights || [],
        summary: result.summary || '',
        stats: {
          conversationsAnalyzed: result.conversationsAnalyzed || 0,
          chatMessagesAnalyzed: result.chatHistoryAnalyzed || 0,
          insightsGenerated: result.insights?.length || 0,
          costEstimate: result.costEstimate || 0
        },
        processingTime,
        dataHash: result.dataHash || '',
        message: hasMarkedConversations 
          ? `An√°lise realizada com ${markedConversations.length} conversas marcadas prioritariamente`
          : result.message || 'An√°lise realizada com sucesso'
      };

    } catch (error: any) {
      console.error('üîí SISTEMA PROTEGIDO: Erro na an√°lise:', error);
      
      // Marcar conversas como failed se houver erro
      if (markedConversations && markedConversations.length > 0) {
        for (const conversation of markedConversations) {
          await supabase
            .from('whatsapp_conversations_analysis')
            .update({ analysis_status: 'failed' })
            .eq('id', conversation.id);
        }
      }
      
      return {
        success: false,
        fromCache: false,
        insights: [],
        summary: '',
        stats: { conversationsAnalyzed: 0, chatMessagesAnalyzed: 0, insightsGenerated: 0, costEstimate: 0 },
        processingTime: 0,
        dataHash: '',
        message: error.message || 'Erro na an√°lise'
      };
    } finally {
      setIsAnalyzing(false);
    }
  }, [user?.id, checkAnalysisCache]);

  /**
   * FUN√á√ÉO PROTEGIDA PARA BUSCAR DADOS REAIS
   * Agora inclui conversas marcadas para an√°lise
   */
  const fetchRealUserData = useCallback(async (userId: string, markedConversations: any[] = []) => {
    console.log('üîí SISTEMA PROTEGIDO: Buscando dados reais do usu√°rio...');
    
    try {
      // Buscar conversa√ß√µes do WhatsApp
      const { data: whatsappConversations, error: whatsappError } = await supabase
        .from('whatsapp_conversations')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false })
        .limit(50);

      if (whatsappError) {
        console.warn('üîí SISTEMA PROTEGIDO: Erro ao buscar WhatsApp:', whatsappError);
      }

      // Buscar conversa√ß√µes comerciais
      const { data: commercialConversations, error: commercialError } = await supabase
        .from('commercial_conversations')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false })
        .limit(50);

      if (commercialError) {
        console.warn('üîí SISTEMA PROTEGIDO: Erro ao buscar comercial:', commercialError);
      }

      // Buscar hist√≥rico de chat
      const { data: chatHistory, error: chatError } = await supabase
        .from('chat_history')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false })
        .limit(100);

      if (chatError) {
        console.warn('üîí SISTEMA PROTEGIDO: Erro ao buscar chat:', chatError);
      }

      const conversations = [
        ...(whatsappConversations || []),
        ...(commercialConversations || [])
      ];

      // Adicionar informa√ß√µes das conversas marcadas
      if (markedConversations.length > 0) {
        console.log(`üéØ SISTEMA PROTEGIDO: Priorizando ${markedConversations.length} conversas marcadas`);
        conversations.forEach(conv => {
          const marked = markedConversations.find(m => m.chat_id === conv.id);
          if (marked) {
            (conv as any).markedForAnalysis = true;
            (conv as any).analysisPriority = marked.priority;
            (conv as any).markedAt = marked.marked_at;
          }
        });
      }

      console.log(`üîí SISTEMA PROTEGIDO: Dados reais carregados - ${conversations.length} conversas, ${(chatHistory || []).length} mensagens`);

      return {
        conversations,
        chatHistory: chatHistory || []
      };

    } catch (error) {
      console.error('üîí SISTEMA PROTEGIDO: Erro ao buscar dados reais:', error);
      return null;
    }
  }, []);

  /**
   * FUN√á√ÉO PARA VALIDAR CONFIGURA√á√ÉO
   * Garante que a configura√ß√£o est√° correta antes da an√°lise
   */
  const validateAnalysisConfig = useCallback((config: ProtectedAnalysisConfig): boolean => {
    if (!config.analysisType || config.analysisType.length === 0) {
      console.error('üîí SISTEMA PROTEGIDO: Tipo de an√°lise n√£o definido');
      return false;
    }

    if (!config.assistants || config.assistants.length === 0) {
      console.error('üîí SISTEMA PROTEGIDO: Nenhum assistente configurado');
      return false;
    }

    if (!config.openaiConfig || !config.openaiConfig.apiKey) {
      console.error('üîí SISTEMA PROTEGIDO: Configura√ß√£o OpenAI inv√°lida');
      return false;
    }

    for (const assistant of config.assistants) {
      if (!assistant.id || !assistant.name || !assistant.prompt) {
        console.error('üîí SISTEMA PROTEGIDO: Assistente inv√°lido:', assistant);
        return false;
      }
    }

    return true;
  }, []);

  /**
   * FUN√á√ÉO PARA OBTER STATUS DO SISTEMA
   * Retorna informa√ß√µes sobre o estado atual do sistema protegido
   */
  const getSystemStatus = useCallback(() => {
    return {
      isActive: true,
      protectionLevel,
      isAnalyzing,
      version: '2.0',
      features: [
        'Cache inteligente',
        'Dados reais garantidos',
        'Controle de custos',
        'Prote√ß√£o contra duplica√ß√£o',
        'Valida√ß√£o robusta'
      ]
    };
  }, [protectionLevel, isAnalyzing]);

  return {
    executeProtectedAnalysis,
    validateAnalysisConfig,
    getSystemStatus,
    isAnalyzing,
    protectionLevel,
    setProtectionLevel
  };
}
